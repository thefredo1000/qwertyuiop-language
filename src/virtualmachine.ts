const SCOPE_MEM_SIZE = 100000;
const TYPE_MEM_SIZE = SCOPE_MEM_SIZE / 10;

import { Stack } from "@datastructures-js/stack";
import { min, max, product, mean, mode, median } from "simple-statistics";
var asciichart = require("asciichart");

interface MemoryBatch {
  [key: string]: Array<any>;
}

interface Quadruple {
  op: string;
  arg1: string | undefined;
  arg2: string | undefined;
  result: string | undefined;
}

interface Mem {
  [key: string]: MemoryBatch;
}
interface Func {
  type: string;
  nLocalVar: number;
  quadCount: number;
  quadStart: number;
  parameterTable: Array<string>;
  scope: number;
}

interface DirFunc {
  [key: string]: Func;
}

function newMemoryBatch(): MemoryBatch {
  return {
    int: [],
    float: [],
    char: [],
    string: [],
    bool: [],
  };
}
/*
  The Virtual Machine class is responsible for executing the code
  generated by the compiler.
  */
class VirtualMachine {
  instructionPointer: number;
  instructionPointerStack: Stack<number> = new Stack();

  varTable: Array<{ varName: string; dir: number; dim?: number }>;

  dim: Array<{
    lsup: number;
    m: number | undefined;
    next: number | undefined;
  }> = [];

  memory: Mem = {};
  quadruples: Array<Quadruple> = new Array<Quadruple>();
  dirFunc: DirFunc;
  funcCounter: {
    [key: string]: number;
  } = {};
  returnStack: { [key: string]: Stack<any> } = {};
  currFunc: string = "";
  functionStack: Stack<string> = new Stack();
  paramCounter: number = 0;

  /*
  We pass the quads, the dirFunc, the varTable and the memory
  */
  constructor(
    quadruples: Array<Quadruple>,
    dirFunc: DirFunc,
    memory: Mem,
    varTable: Array<{ varName: string; dir: number; dim?: number }>,
    dim: Array<{
      lsup: number;
      m: number | undefined;
      next: number | undefined;
    }>
  ) {
    this.quadruples = quadruples;
    this.dirFunc = dirFunc;
    this.memory = memory;

    this.varTable = varTable;
    this.dim = dim;

    this.instructionPointer = 0;
  }

  /*
  We exectue the quads until we reach the end of the program
  */
  run() {
    while (this.instructionPointer < this.quadruples.length) {
      this.execute(this.quadruples[this.instructionPointer]);
      this.instructionPointer++;
    }
  }

  /*
  Depending on what OPCODE we have, we execute the corresponding function.
  */
  execute(quadruple: Quadruple) {
    switch (quadruple.op) {
      case "+":
        this.add(quadruple);
        break;
      case "-":
        this.sub(quadruple);
        break;
      case "*":
        this.mul(quadruple);
        break;
      case "/":
        this.div(quadruple);
        break;
      case "=":
        this.assign(quadruple);
        break;
      case "=f":
        this.assignFunction(quadruple);
        break;
      case ">":
        this.greaterThan(quadruple);
        break;
      case "<":
        this.lessThan(quadruple);
        break;
      case ">=":
        this.greaterOrEqualThan(quadruple);
        break;
      case "<=":
        this.lessOrEqualThan(quadruple);
        break;
      case "==":
        this.equal(quadruple);
        break;
      case "!=":
        this.notEqual(quadruple);
        break;
      case "&&":
        this.and(quadruple);
        break;
      case "||":
        this.or(quadruple);
        break;
      case "GOTO":
        this.goTo(quadruple);
        break;
      case "GOTOF":
        this.goToF(quadruple);
        break;
      case "ERA":
        this.era(quadruple);
        break;
      case "PARAM":
        this.param(quadruple);
        break;
      case "GOSUB":
        this.goSub(quadruple);
        break;
      case "ENDFUNC":
        this.endfunc(quadruple);
        break;
      case "RETURN":
        this.return(quadruple);
        break;
      case "PRINT":
        this.print(quadruple);
        break;
      case "SUM":
        this.sum(quadruple);
        break;
      case "RAND":
        this.rand(quadruple);
        break;
      case "MIN":
        this.min(quadruple);
        break;
      case "MAX":
        this.max(quadruple);
        break;
      case "PROD":
        this.prod(quadruple);
        break;
      case "MEAN":
        this.mean(quadruple);
        break;
      case "MODE":
        this.mode(quadruple);
        break;
      case "MEDIAN":
        this.median(quadruple);
        break;
      case "FIND":
        this.find(quadruple);
        break;
      case "SORT":
        this.sort(quadruple);
        break;
      case "CHART":
        this.chart(quadruple);
        break;
      case "SIN":
        this.sin(quadruple);
        break;
      case "COS":
        this.cos(quadruple);
        break;
      case "TAN":
        this.tan(quadruple);
        break;
      default:
        break;
    }
  }

  /*
  Returns the type of an address in memory.
  */
  getAddressType(dir: number) {
    const type = (Math.floor(dir / TYPE_MEM_SIZE) % 10) % 5;
    if (type === 0) {
      return "int";
    } else if (type === 1) {
      return "float";
    } else if (type === 2) {
      return "char";
    } else if (type === 3) {
      return "string";
    } else if (type === 4) {
      return "bool";
    }
    return "null";
  }

  /*
  Returns the scope of an address in memory.
  */
  getScope(dir: number) {
    const type = Math.floor(dir / TYPE_MEM_SIZE) % 10;
    return this.dirFunc[Object.keys(this.dirFunc)[type]].scope;
  }
  /*
  Returns the value of an address in memory.
  */
  getValueInMemory(key: string): number {
    if (key && key[0] === "*") {
      const aux = this.getValueInMemory(key.slice(1));
      return aux;
    }
    const dir = parseInt(key);

    const scopeBase = Math.floor(dir / SCOPE_MEM_SIZE) % SCOPE_MEM_SIZE;
    const valType = this.getAddressType(dir);

    const base =
      scopeBase * SCOPE_MEM_SIZE +
      ((Math.floor(dir / TYPE_MEM_SIZE) % 10) % 5) * TYPE_MEM_SIZE;

    const scope = Object.keys(this.memory)[scopeBase];
    const scopeCount = Object.keys(this.funcCounter).find(
      (key) => key === scope
    );
    if (scopeCount !== undefined) {
      const val =
        this.memory[
          scopeCount +
            (!(this.funcCounter[scopeCount] - 1)
              ? this.funcCounter[scopeCount]
              : this.funcCounter[scopeCount] - 1)
        ][valType][dir - base];
      return val;
    } else {
      const val = this.memory[scope][valType][dir - base];
      return val;
    }
  }
  /*
  Sets value of an address in memory.
  */
  setValueInMemory(key: any, value: any) {
    if (key && key[0] === "*") {
      key = key.replace("*", "");
      const temp = this.getValueInMemory(key);
      if (temp === undefined) {
        return;
      }
      key = temp.toString();
    }
    const dir = parseInt(key);
    const scopeBase = Math.floor(dir / SCOPE_MEM_SIZE) % SCOPE_MEM_SIZE;
    const valType = this.getAddressType(dir);
    const base =
      scopeBase * SCOPE_MEM_SIZE +
      ((Math.floor(dir / TYPE_MEM_SIZE) % 10) % 5) * TYPE_MEM_SIZE;

    const scope = Object.keys(this.memory)[scopeBase];
    const scopeCount = Object.keys(this.funcCounter).find(
      (key) => key === scope
    );
    if (scopeCount !== undefined) {
      this.funcCounter[scopeCount]++;
      this.memory[scopeCount + this.funcCounter[scopeCount]][valType][
        dir - base
      ] = value;
      this.funcCounter[scopeCount]--;
    } else {
      this.memory[scope][valType][dir - base] = value;
    }
  }

  /*
  Adds two values on the address from arg1 and arg2 and stores the 
  result in the address from result.
  */
  add(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    let result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1 = this.getValueInMemory(arg1);
      const temp = this.getValueInMemory(arg2);
      const temp2 = typeof temp === "string" ? parseInt(temp) : temp;
      const val2 = temp2 + (result[0] === "*" ? 1 : 0);
      if (result[0] === "*") {
        result = result.slice(1);
      }
      if (
        this.getAddressType(parseInt(arg1)) === "int" &&
        this.getAddressType(parseInt(arg2)) === "int"
      ) {
        const valResult = Math.floor(Number(val1) + Number(val2));
        this.setValueInMemory(result, valResult);
      } else {
        const valResult = Number(val1) + Number(val2);
        this.setValueInMemory(result, valResult);
      }
    }
  }
  /*
  Subtracts two values on the address from arg1 and arg2 and stores the 
  result in the address from result.
  */
  sub(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1 = this.getValueInMemory(arg1);
      const val2 = this.getValueInMemory(arg2);

      if (
        this.getAddressType(parseInt(arg1)) === "int" &&
        this.getAddressType(parseInt(arg2)) === "int"
      ) {
        const valResult = Math.floor(Number(val1) - Number(val2));
        this.setValueInMemory(result, valResult);
      } else {
        const valResult = Number(val1) - Number(val2);
        this.setValueInMemory(result, valResult);
      }
    }
  }
  /*
  Multiplies two values on the address from arg1 and arg2 and stores the 
  result in the address from result.
  */
  mul(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1 = this.getValueInMemory(arg1);
      const val2 = this.getValueInMemory(arg2);
      if (
        this.getAddressType(parseInt(arg1)) === "int" &&
        this.getAddressType(parseInt(arg2)) === "int"
      ) {
        const valResult = Math.floor(Number(val1) * Number(val2));
        this.setValueInMemory(result, valResult);
      } else {
        const valResult = Number(val1) * Number(val2);
        this.setValueInMemory(result, valResult);
      }
    }
  }
  /*
  Divides two values on the address from arg1 and arg2 and stores the 
  result in the address from result.
  */
  div(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1 = this.getValueInMemory(arg1);
      const val2 = this.getValueInMemory(arg2);

      if (
        this.getAddressType(parseInt(arg1)) === "int" &&
        this.getAddressType(parseInt(arg2)) === "int"
      ) {
        const valResult = Math.floor(Number(val1) / Number(val2));
        this.setValueInMemory(result, valResult);
      } else {
        const valResult = Number(val1) / Number(val2);
        this.setValueInMemory(result, valResult);
      }
    }
  }
  /*
  Compares with an AND two values are on the address from arg1 and arg2 
  and stores the result in the address from result.
  */
  and(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1: boolean = this.getValueInMemory(arg1) ? true : false;
      const val2: boolean = this.getValueInMemory(arg2) ? true : false;

      const valResult: boolean = val1 && val2;
      this.setValueInMemory(result, valResult ? 1 : 0);
    }
  }
  /*
  Compares with an OR two values are on the address from arg1 and arg2 
  and stores the result in the address from result.
  */
  or(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1: boolean = this.getValueInMemory(arg1) ? true : false;
      const val2: boolean = this.getValueInMemory(arg2) ? true : false;

      const valResult: boolean = val1 || val2;
      this.setValueInMemory(result, valResult ? 1 : 0);
    }
  }
  /*
  Assigns the returning value of a function to the address from result.
  */
  assignFunction(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const aux = quadruple.result ? quadruple.result : "";
    const result: any =
      aux[0] === "*" ? (this.getValueInMemory(aux) + 1).toString() : aux;

    if (arg1) {
      // We set the top of the function return stack to the value
      this.setValueInMemory(result, this.returnStack[this.currFunc].pop());
    }
  }

  /*
  Assigns the value from the arg1 address to the address from result.
  */
  assign(quadruple: Quadruple) {
    const arg1Aux: string = quadruple.arg1 !== undefined ? quadruple.arg1 : "";
    const arg1 =
      arg1Aux[0] === "*"
        ? (this.getValueInMemory(arg1Aux) + 1).toString()
        : arg1Aux;
    const aux = quadruple.result ? quadruple.result : "";
    /* 
    If the value in address result is a pointer, 
    get the value from the memory and we use that instead.
    */
    const result: any =
      aux[0] === "*" ? (this.getValueInMemory(aux) + 1).toString() : aux;

    if (arg1) {
      const val1 = this.getValueInMemory(arg1);
      if (this.getAddressType(parseInt(result)) === "int") {
        const valResult = Math.floor(Number(val1));
        this.funcCounter[this.currFunc]--;
        this.setValueInMemory(result, valResult);
        this.funcCounter[this.currFunc]++;
      } else if (this.getAddressType(parseInt(result)) === "float") {
        const valResult = Number(val1);
        this.funcCounter[this.currFunc]--;
        this.setValueInMemory(result, valResult);
        this.funcCounter[this.currFunc]++;
      } else {
        const valResult = val1;
        this.funcCounter[this.currFunc]--;
        this.setValueInMemory(result, valResult);
        this.funcCounter[this.currFunc]++;
      }
    }
  }
  /*
  Returns the dim at the index of the dim array.
  */
  getDimAt(index: number) {
    return this.dim[index];
  }
  /*
  Returns the array in memory as an array depending on the dimensions.
  */
  exportArray(val: { varName: string; dir: number; dim?: number }) {
    if (val.dim === undefined) {
      return;
    }
    var dim = this.getDimAt(val.dim);
    let dimensions = [];
    while (dim !== undefined) {
      dimensions.push(dim.lsup);
      if (dim.next !== undefined) {
        dim = this.getDimAt(dim.next);
      } else {
        break;
      }
    }
    let total = dimensions.reduce((a, b) => a * b, 1);
    let res: any[] = [];
    for (let i = 2; i <= total + 1; i++) {
      res.push(this.getValueInMemory((val.dir + i).toString()));
    }

    let temp: any[][] = [];
    if (dimensions.length > 1) {
      dimensions.forEach((element) => {
        while (res.length) temp.push(res.splice(0, element + 1));
      });
    }
    res = temp.length > 0 ? temp : res;

    return res;
  }
  /*
  Sets an array in memory. It is used to modify the existing array.
  */
  importArray(val: { varName: string; dir: number; dim?: number }, arr: any) {
    if (val.dim === undefined) {
      return;
    }
    var dim = this.getDimAt(val.dim);
    let dimensions = [];
    while (dim !== undefined) {
      dimensions.push(dim.lsup);
      if (dim.next !== undefined) {
        dim = this.getDimAt(dim.next);
      } else {
        break;
      }
    }
    let total = dimensions.reduce((a, b) => a * b, 1);
    let res = [];
    for (let i = 2; i <= total + 1; i++) {
      res.push(this.getValueInMemory((val.dir + i).toString()));
      this.setValueInMemory((val.dir + i).toString(), arr[i - 2]);
    }
    return res;
  }
  /*
  Sums all the values in the array and returns the result. This is a helper function.
  */
  sumArray(val: { varName: string; dir: number; dim?: number }) {
    const arr = this.exportArray(val);
    if (arr === undefined) {
      return 0;
    }
    return arr.reduce((partialSum, a) => partialSum + a, 0);
  }
  /*
  Prints an array in the console.
  */
  printArray(val: { varName: string; dir: number; dim?: number }) {
    console.log(this.exportArray(val));
  }

  /*
  Sums all the values in the array and sets the result in memory.
  */
  sum(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        let result = quadruple.result;

        this.setValueInMemory(result, this.sumArray(e));
      } else if (arg1[0] === "*") {
        throw new Error(
          `sum() function can only be used with arrays, not with ${arg1}`
        );
      }
    } else {
      console.log("null");
    }
  }

  /*
  Generates a random number and sets it in memory.
  */
  rand(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      let result = quadruple.result;
      const arr = this.getValueInMemory(arg1);
      this.setValueInMemory(result, Math.floor(Math.random() * Number(arr)));
    } else {
      console.log("null");
    }
  }

  /*
  Obtains the minimum value in the array and sets it in memory.
  */
  min(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        let result = quadruple.result;
        const arr = this.exportArray(e);
        if (arr === undefined) {
          throw new Error(
            `sum() function can only be used with arrays, not with ${arg1}`
          );
        }

        this.setValueInMemory(result, min(arr));
      } else if (arg1[0] === "*") {
        throw new Error(
          `sum() function can only be used with arrays, not with ${arg1}`
        );
      }
    } else {
      console.log("null");
    }
  }
  /*
  Obtains the maximum value in the array and sets it in memory.
  */
  max(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        let result = quadruple.result;
        const arr = this.exportArray(e);
        if (arr === undefined) {
          throw new Error(
            `sum() function can only be used with arrays, not with ${arg1}`
          );
        }

        this.setValueInMemory(result, max(arr));
      } else if (arg1[0] === "*") {
        throw new Error(
          `sum() function can only be used with arrays, not with ${arg1}`
        );
      }
    } else {
      console.log("null");
    }
  }

  /*
  Obtains the product of all the values in the array and sets it in memory.
  */
  prod(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        let result = quadruple.result;
        const arr = this.exportArray(e);
        if (arr === undefined) {
          throw new Error(
            `sum() function can only be used with arrays, not with ${arg1}`
          );
        }

        this.setValueInMemory(result, product(arr));
      } else if (arg1[0] === "*") {
        throw new Error(
          `sum() function can only be used with arrays, not with ${arg1}`
        );
      }
    } else {
      console.log("null");
    }
  }
  /*
  Obtains the mean of all the values in the array and sets it in memory.
  */
  mean(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        let result = quadruple.result;
        const arr = this.exportArray(e);
        if (arr === undefined) {
          throw new Error(
            `sum() function can only be used with arrays, not with ${arg1}`
          );
        }

        this.setValueInMemory(result, mean(arr));
      } else if (arg1[0] === "*") {
        throw new Error(
          `sum() function can only be used with arrays, not with ${arg1}`
        );
      }
    } else {
      console.log("null");
    }
  }
  /*
  Obtains the mode of all the values in the array and sets it in memory.
  */
  mode(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        let result = quadruple.result;
        const arr = this.exportArray(e);
        if (arr === undefined) {
          throw new Error(
            `sum() function can only be used with arrays, not with ${arg1}`
          );
        }

        this.setValueInMemory(result, mode(arr));
      } else if (arg1[0] === "*") {
        throw new Error(
          `sum() function can only be used with arrays, not with ${arg1}`
        );
      }
    } else {
      console.log("null");
    }
  }
  /*
  Obtains the median of all the values in the array and sets it in memory.
  */
  median(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        let result = quadruple.result;
        const arr = this.exportArray(e);
        if (arr === undefined) {
          throw new Error(
            `sum() function can only be used with arrays, not with ${arg1}`
          );
        }

        this.setValueInMemory(result, median(arr));
      } else if (arg1[0] === "*") {
        throw new Error(
          `sum() function can only be used with arrays, not with ${arg1}`
        );
      }
    } else {
      console.log("null");
    }
  }
  /*
  Sorts all the values in the array and sets it in memory back to the original array.
  */
  sort(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        let result = quadruple.result;
        const arr = this.exportArray(e);
        if (arr === undefined) {
          throw new Error(
            `sum() function can only be used with arrays, not with ${arg1}`
          );
        }
        this.importArray(
          e,
          arr.sort(function (a, b) {
            return a - b;
          })
        );
      } else if (arg1[0] === "*") {
        throw new Error(
          `sum() function can only be used with arrays, not with ${arg1}`
        );
      }
    } else {
      console.log("null");
    }
  }
  /*
  Finds the position of a value in the array and sets it in memory.
  */
  find(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1 && arg2) {
      if (e && e.dim !== undefined) {
        let result = quadruple.result;
        const arr = this.exportArray(e);
        if (arr === undefined) {
          throw new Error(
            `sum() function can only be used with arrays, not with ${arg1}`
          );
        }
        const val2 = this.getValueInMemory(arg2);
        this.setValueInMemory(
          result,
          arr.findIndex((x: any) => x.toString() === val2)
        );
      } else if (arg1[0] === "*") {
        throw new Error(
          `sum() function can only be used with arrays, not with ${arg1}`
        );
      }
    } else {
      console.log("null");
    }
  }
  /*
  Gets the sine value of a number and sets it in memory.
  */
  sin(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        throw new Error(`sin() function can't be used with arrays`);
      } else if (arg1[0] === "*") {
        const val1 = this.getValueInMemory(arg1);
        const res = Math.sin(this.getValueInMemory((val1 + 1).toString()));
        const resDir = quadruple.result;
        this.setValueInMemory(resDir, res);
      } else {
        const res = Math.sin(this.getValueInMemory(arg1));
        const resDir = quadruple.result;
        this.setValueInMemory(resDir, res);
      }
    } else {
      console.log("null");
    }
  }

  /*
  Gets the cosine value of a number and sets it in memory.
  */
  cos(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        throw new Error(`cos() function can't be used with arrays`);
      } else if (arg1[0] === "*") {
        const val1 = this.getValueInMemory(arg1);
        const res = Math.cos(this.getValueInMemory((val1 + 1).toString()));
        const resDir = quadruple.result;
        this.setValueInMemory(resDir, res);
      } else {
        const res = Math.cos(this.getValueInMemory(arg1));
        const resDir = quadruple.result;
        this.setValueInMemory(resDir, res);
      }
    } else {
      console.log("null");
    }
  }

  /*
  Gets the tanget value of a number and sets it in memory.
  */
  tan(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        throw new Error(`tan() function can't be used with arrays`);
      } else if (arg1[0] === "*") {
        const val1 = this.getValueInMemory(arg1);
        const res = Math.tan(this.getValueInMemory((val1 + 1).toString()));
        const resDir = quadruple.result;
        this.setValueInMemory(resDir, res);
      } else {
        const res = Math.tan(this.getValueInMemory(arg1));
        const resDir = quadruple.result;
        this.setValueInMemory(resDir, res);
      }
    } else {
      console.log("null");
    }
  }

  /*
  Prints the chart of an array.
  */
  chart(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        console.log(asciichart.plot(this.exportArray(e)));
      } else {
        console.log("nulls");
      }
    } else {
      console.log("null");
    }
  }

  /*
  Prints a value or an array in the console.
  */
  print(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const e = this.varTable.find((v) => v.dir.toString() === arg1);
    if (arg1) {
      if (e && e.dim !== undefined) {
        this.printArray(e);
      } else if (arg1[0] === "*") {
        const val1 = this.getValueInMemory(arg1);
        console.log(this.getValueInMemory((val1 + 1).toString()));
      } else {
        console.log(this.getValueInMemory(arg1));
      }
    } else {
      console.log("null");
    }
  }

  /*
  Changes the instruction pointer to the result.
  */
  goTo(quadruple: Quadruple) {
    const result = quadruple.result;
    if (result) {
      this.instructionPointer = parseInt(result) - 1;
    }
  }

  /*
  If the value in arg1 is false, ithanges the instruction
  pointer to the result.
  */
  goToF(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const result = quadruple.result;

    if (arg1 && result) {
      if (this.getValueInMemory(arg1) === 0) {
        this.instructionPointer = parseInt(result) - 1;
      }
    }
  }

  /*
  Compares if the value in arg1 is greater than the value in
  arg2 and stores the result in the address from result.
  */
  greaterThan(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1 = this.getValueInMemory(arg1);
      const val2 = this.getValueInMemory(arg2);

      if (Number(val1) > Number(val2)) {
        this.setValueInMemory(result, 1);
      } else {
        this.setValueInMemory(result, 0);
      }
    }
  }

  /*
  Compares if the value in arg1 is less than the value in arg2
  and stores the result in the address from result.
  */
  lessThan(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1 = this.getValueInMemory(arg1);
      const val2 = this.getValueInMemory(arg2);

      if (Number(val1) < Number(val2)) {
        this.setValueInMemory(result, 1);
      } else {
        this.setValueInMemory(result, 0);
      }
    }
  }

  /*
  Compares if the value in arg1 is greater or equal than the
  value in arg2 and stores the result in the address from result.
  */
  greaterOrEqualThan(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1 = this.getValueInMemory(arg1);
      const val2 = this.getValueInMemory(arg2);

      if (Number(val1) >= Number(val2)) {
        this.setValueInMemory(result, 1);
      } else {
        this.setValueInMemory(result, 0);
      }
    }
  }

  /*
  Compares if the value in arg1 is less or equal than the value
  in arg2 and stores the result in the address from result.
  */
  lessOrEqualThan(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1 = this.getValueInMemory(arg1);
      const val2 = this.getValueInMemory(arg2);
      if (Number(val1) <= Number(val2)) {
        this.setValueInMemory(result, 1);
      } else {
        this.setValueInMemory(result, 0);
      }
    }
  }

  /*
  Compares if the value in arg1 is equal than the value in
  arg2 and stores the result in the address from result.
  */
  equal(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val2 = this.getValueInMemory(arg2);
      const val1 = this.getValueInMemory(arg1);
      if (val1.toString() === val2.toString()) {
        this.setValueInMemory(result, 1);
      } else {
        this.setValueInMemory(result, 0);
      }
    }
  }

  /*
  Compares if the value in arg1 is not equal than the value
  in arg2 and stores the result in the address from result.
  */
  notEqual(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const arg2 = quadruple.arg2;
    const result = quadruple.result;

    if (arg1 && arg2 && result) {
      const val1 = this.getValueInMemory(arg1);
      const val2 = this.getValueInMemory(arg2);
      if (val1.toString() !== val2.toString()) {
        this.setValueInMemory(result, 1);
      } else {
        this.setValueInMemory(result, 0);
      }
    }
  }

  /*
  Starts the call of a function. Adds one to the respective
  function counter, adds the function space into memory and
  adds the function call to the function directory.
  */
  era(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    if (arg1) {
      if (this.funcCounter[arg1] === undefined) {
        this.dirFunc[arg1].quadCount = this.dirFunc[arg1].quadCount + 1;
      }
      const func =
        this.dirFunc[
          arg1 + (this.funcCounter[arg1] ? this.funcCounter[arg1] : "")
        ];
      if (!func) {
        throw new Error(`Function ${func} not found`);
      }

      if (this.funcCounter[arg1] === undefined) {
        this.funcCounter[arg1] = 1;
      } else {
        this.funcCounter[arg1]++;
      }
      this.currFunc = arg1;
      this.memory[arg1 + this.funcCounter[arg1]] = newMemoryBatch();
      this.functionStack.push(arg1 + this.funcCounter[arg1]);
      this.dirFunc[arg1 + this.funcCounter[arg1]] = Object.assign(
        {},
        this.dirFunc[arg1]
      );
      this.dirFunc[arg1 + this.funcCounter[arg1]].parameterTable = this.dirFunc[
        arg1 + this.funcCounter[arg1]
      ].parameterTable.map((p) => {
        return ((Object.keys(this.memory).length - 1) * 100000).toString();
      });
    }
  }

  /*
  Changes the instruction pointer to the position where the function is.
  */
  goSub(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const res = quadruple.result;
    if (arg1) {
      if (
        this.paramCounter <
        this.dirFunc[this.functionStack.peek()].parameterTable.length
      ) {
        throw new Error("Not enough parameters");
      }

      this.instructionPointerStack.push(this.instructionPointer);
      this.instructionPointer = parseInt(arg1) - 1;
    }
    this.paramCounter = 0;
  }

  /*
  Returns to where the function was called.
  */
  endfunc(quadruple: Quadruple) {
    this.instructionPointer = this.instructionPointerStack.pop();
  }

  /*
  Returns the value in the address from arg1 and stores it in the
  address from result.
  */
  return(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    const result = quadruple.result;

    if (arg1 && result) {
      const val1 = this.getValueInMemory(arg1);

      if (this.getAddressType(parseInt(result)) === "int") {
        const valResult = Math.floor(Number(val1));
        this.setValueInMemory(result, valResult);
      } else if (this.getAddressType(parseInt(result)) === "float") {
        const valResult = Number(val1);
        this.setValueInMemory(result, valResult);
      } else {
        const valResult = val1;
        this.setValueInMemory(result, valResult);
      }
      if (this.returnStack[this.currFunc] === undefined) {
        this.returnStack[this.currFunc] = new Stack<any>([
          this.getValueInMemory(result),
        ]);
      } else {
        this.returnStack[this.currFunc].push(this.getValueInMemory(result));
        this.funcCounter[this.currFunc]--;
      }
    }
    const aux = this.quadruples[this.instructionPointerStack.peek()];

    this.instructionPointer = this.instructionPointerStack.pop();
  }


  /*
  Sets the value in the address from arg1 to the parameter of the function.
  */
  param(quadruple: Quadruple) {
    const arg1 = quadruple.arg1;
    if (arg1) {
      if (
        this.paramCounter >=
        this.dirFunc[
          this.functionStack.peek() +
            (this.funcCounter[arg1] ? this.funcCounter[arg1] : "")
        ].parameterTable.length
      ) {
        throw new Error("Too many parameters");
      }

      const val1 = isNaN(this.getValueInMemory(arg1))
        ? 0
        : this.getValueInMemory(arg1);
      const dir =
        this.dirFunc[
          this.functionStack.peek() +
            (this.funcCounter[arg1] ? this.funcCounter[arg1] : "")
        ].parameterTable[this.paramCounter];

      if (
        this.getAddressType(parseInt(dir)) !==
        this.getAddressType(parseInt(arg1))
      ) {
        throw new Error("Type mismatch");
      }
      this.setValueInMemory(dir.toString(), val1);
      this.paramCounter++;
    }
  }
}

export = VirtualMachine;
