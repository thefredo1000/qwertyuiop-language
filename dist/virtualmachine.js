"use strict";
const SCOPE_MEM_SIZE = 100000;
const TYPE_MEM_SIZE = SCOPE_MEM_SIZE / 10;
const stack_1 = require("@datastructures-js/stack");
const simple_statistics_1 = require("simple-statistics");
var asciichart = require("asciichart");
function newMemoryBatch() {
    return {
        int: [],
        float: [],
        char: [],
        string: [],
        bool: [],
    };
}
/*
  The Virtual Machine class is responsible for executing the code
  generated by the compiler.
  */
class VirtualMachine {
    /*
    We pass the quads, the dirFunc, the varTable and the memory
    */
    constructor(quadruples, dirFunc, memory, varTable, dim) {
        this.instructionPointerStack = new stack_1.Stack();
        this.dim = [];
        this.memory = {};
        this.quadruples = new Array();
        this.funcCounter = {};
        this.returnStack = {};
        this.currFunc = "";
        this.functionStack = new stack_1.Stack();
        this.paramCounter = 0;
        this.quadruples = quadruples;
        this.dirFunc = dirFunc;
        this.memory = memory;
        this.varTable = varTable;
        this.dim = dim;
        this.instructionPointer = 0;
    }
    /*
    We exectue the quads until we reach the end of the program
    */
    run() {
        while (this.instructionPointer < this.quadruples.length) {
            this.execute(this.quadruples[this.instructionPointer]);
            this.instructionPointer++;
        }
    }
    /*
    Depending on what OPCODE we have, we execute the corresponding function.
    */
    execute(quadruple) {
        switch (quadruple.op) {
            case "+":
                this.add(quadruple);
                break;
            case "-":
                this.sub(quadruple);
                break;
            case "*":
                this.mul(quadruple);
                break;
            case "/":
                this.div(quadruple);
                break;
            case "=":
                this.assign(quadruple);
                break;
            case "=f":
                this.assignFunction(quadruple);
                break;
            case ">":
                this.greaterThan(quadruple);
                break;
            case "<":
                this.lessThan(quadruple);
                break;
            case ">=":
                this.greaterOrEqualThan(quadruple);
                break;
            case "<=":
                this.lessOrEqualThan(quadruple);
                break;
            case "==":
                this.equal(quadruple);
                break;
            case "!=":
                this.notEqual(quadruple);
                break;
            case "&&":
                this.and(quadruple);
                break;
            case "||":
                this.or(quadruple);
                break;
            case "GOTO":
                this.goTo(quadruple);
                break;
            case "GOTOF":
                this.goToF(quadruple);
                break;
            case "ERA":
                this.era(quadruple);
                break;
            case "PARAM":
                this.param(quadruple);
                break;
            case "GOSUB":
                this.goSub(quadruple);
                break;
            case "ENDFUNC":
                this.endfunc(quadruple);
                break;
            case "RETURN":
                this.return(quadruple);
                break;
            case "PRINT":
                this.print(quadruple);
                break;
            case "SUM":
                this.sum(quadruple);
                break;
            case "RAND":
                this.rand(quadruple);
                break;
            case "MIN":
                this.min(quadruple);
                break;
            case "MAX":
                this.max(quadruple);
                break;
            case "PROD":
                this.prod(quadruple);
                break;
            case "MEAN":
                this.mean(quadruple);
                break;
            case "MODE":
                this.mode(quadruple);
                break;
            case "MEDIAN":
                this.median(quadruple);
                break;
            case "FIND":
                this.find(quadruple);
                break;
            case "SORT":
                this.sort(quadruple);
                break;
            case "CHART":
                this.chart(quadruple);
                break;
            case "SIN":
                this.sin(quadruple);
                break;
            case "COS":
                this.cos(quadruple);
                break;
            case "TAN":
                this.tan(quadruple);
                break;
            default:
                break;
        }
    }
    /*
    Returns the type of an address in memory.
    */
    getAddressType(dir) {
        const type = (Math.floor(dir / TYPE_MEM_SIZE) % 10) % 5;
        if (type === 0) {
            return "int";
        }
        else if (type === 1) {
            return "float";
        }
        else if (type === 2) {
            return "char";
        }
        else if (type === 3) {
            return "string";
        }
        else if (type === 4) {
            return "bool";
        }
        return "null";
    }
    /*
    Returns the scope of an address in memory.
    */
    getScope(dir) {
        const type = Math.floor(dir / TYPE_MEM_SIZE) % 10;
        return this.dirFunc[Object.keys(this.dirFunc)[type]].scope;
    }
    /*
    Returns the value of an address in memory.
    */
    getValueInMemory(key) {
        if (key && key[0] === "*") {
            const aux = this.getValueInMemory(key.slice(1));
            return aux;
        }
        const dir = parseInt(key);
        const scopeBase = Math.floor(dir / SCOPE_MEM_SIZE) % SCOPE_MEM_SIZE;
        const valType = this.getAddressType(dir);
        const base = scopeBase * SCOPE_MEM_SIZE +
            ((Math.floor(dir / TYPE_MEM_SIZE) % 10) % 5) * TYPE_MEM_SIZE;
        const scope = Object.keys(this.memory)[scopeBase];
        const scopeCount = Object.keys(this.funcCounter).find((key) => key === scope);
        if (scopeCount !== undefined) {
            const val = this.memory[scopeCount +
                (!(this.funcCounter[scopeCount] - 1)
                    ? this.funcCounter[scopeCount]
                    : this.funcCounter[scopeCount] - 1)][valType][dir - base];
            return val;
        }
        else {
            const val = this.memory[scope][valType][dir - base];
            return val;
        }
    }
    /*
    Sets value of an address in memory.
    */
    setValueInMemory(key, value) {
        if (key && key[0] === "*") {
            key = key.replace("*", "");
            const temp = this.getValueInMemory(key);
            if (temp === undefined) {
                return;
            }
            key = temp.toString();
        }
        const dir = parseInt(key);
        const scopeBase = Math.floor(dir / SCOPE_MEM_SIZE) % SCOPE_MEM_SIZE;
        const valType = this.getAddressType(dir);
        const base = scopeBase * SCOPE_MEM_SIZE +
            ((Math.floor(dir / TYPE_MEM_SIZE) % 10) % 5) * TYPE_MEM_SIZE;
        const scope = Object.keys(this.memory)[scopeBase];
        const scopeCount = Object.keys(this.funcCounter).find((key) => key === scope);
        if (scopeCount !== undefined) {
            this.funcCounter[scopeCount]++;
            this.memory[scopeCount + this.funcCounter[scopeCount]][valType][dir - base] = value;
            this.funcCounter[scopeCount]--;
        }
        else {
            this.memory[scope][valType][dir - base] = value;
        }
    }
    /*
    Adds two values on the address from arg1 and arg2 and stores the
    result in the address from result.
    */
    add(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        let result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1);
            const temp = this.getValueInMemory(arg2);
            const temp2 = typeof temp === "string" ? parseInt(temp) : temp;
            const val2 = temp2 + (result[0] === "*" ? 1 : 0);
            if (result[0] === "*") {
                result = result.slice(1);
            }
            if (this.getAddressType(parseInt(arg1)) === "int" &&
                this.getAddressType(parseInt(arg2)) === "int") {
                const valResult = Math.floor(Number(val1) + Number(val2));
                this.setValueInMemory(result, valResult);
            }
            else {
                const valResult = Number(val1) + Number(val2);
                this.setValueInMemory(result, valResult);
            }
        }
    }
    /*
    Subtracts two values on the address from arg1 and arg2 and stores the
    result in the address from result.
    */
    sub(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1);
            const val2 = this.getValueInMemory(arg2);
            if (this.getAddressType(parseInt(arg1)) === "int" &&
                this.getAddressType(parseInt(arg2)) === "int") {
                const valResult = Math.floor(Number(val1) - Number(val2));
                this.setValueInMemory(result, valResult);
            }
            else {
                const valResult = Number(val1) - Number(val2);
                this.setValueInMemory(result, valResult);
            }
        }
    }
    /*
    Multiplies two values on the address from arg1 and arg2 and stores the
    result in the address from result.
    */
    mul(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1);
            const val2 = this.getValueInMemory(arg2);
            if (this.getAddressType(parseInt(arg1)) === "int" &&
                this.getAddressType(parseInt(arg2)) === "int") {
                const valResult = Math.floor(Number(val1) * Number(val2));
                this.setValueInMemory(result, valResult);
            }
            else {
                const valResult = Number(val1) * Number(val2);
                this.setValueInMemory(result, valResult);
            }
        }
    }
    /*
    Divides two values on the address from arg1 and arg2 and stores the
    result in the address from result.
    */
    div(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1);
            const val2 = this.getValueInMemory(arg2);
            if (this.getAddressType(parseInt(arg1)) === "int" &&
                this.getAddressType(parseInt(arg2)) === "int") {
                const valResult = Math.floor(Number(val1) / Number(val2));
                this.setValueInMemory(result, valResult);
            }
            else {
                const valResult = Number(val1) / Number(val2);
                this.setValueInMemory(result, valResult);
            }
        }
    }
    /*
    Compares with an AND two values are on the address from arg1 and arg2
    and stores the result in the address from result.
    */
    and(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1) ? true : false;
            const val2 = this.getValueInMemory(arg2) ? true : false;
            const valResult = val1 && val2;
            this.setValueInMemory(result, valResult ? 1 : 0);
        }
    }
    /*
    Compares with an OR two values are on the address from arg1 and arg2
    and stores the result in the address from result.
    */
    or(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1) ? true : false;
            const val2 = this.getValueInMemory(arg2) ? true : false;
            const valResult = val1 || val2;
            this.setValueInMemory(result, valResult ? 1 : 0);
        }
    }
    /*
    Assigns the returning value of a function to the address from result.
    */
    assignFunction(quadruple) {
        const arg1 = quadruple.arg1;
        const aux = quadruple.result ? quadruple.result : "";
        const result = aux[0] === "*" ? (this.getValueInMemory(aux) + 1).toString() : aux;
        if (arg1) {
            // We set the top of the function return stack to the value
            this.setValueInMemory(result, this.returnStack[this.currFunc].pop());
        }
    }
    /*
    Assigns the value from the arg1 address to the address from result.
    */
    assign(quadruple) {
        const arg1Aux = quadruple.arg1 !== undefined ? quadruple.arg1 : "";
        const arg1 = arg1Aux[0] === "*"
            ? (this.getValueInMemory(arg1Aux) + 1).toString()
            : arg1Aux;
        const aux = quadruple.result ? quadruple.result : "";
        /*
        If the value in address result is a pointer,
        get the value from the memory and we use that instead.
        */
        const result = aux[0] === "*" ? (this.getValueInMemory(aux) + 1).toString() : aux;
        if (arg1) {
            const val1 = this.getValueInMemory(arg1);
            if (this.getAddressType(parseInt(result)) === "int") {
                const valResult = Math.floor(Number(val1));
                this.funcCounter[this.currFunc]--;
                this.setValueInMemory(result, valResult);
                this.funcCounter[this.currFunc]++;
            }
            else if (this.getAddressType(parseInt(result)) === "float") {
                const valResult = Number(val1);
                this.funcCounter[this.currFunc]--;
                this.setValueInMemory(result, valResult);
                this.funcCounter[this.currFunc]++;
            }
            else {
                const valResult = val1;
                this.funcCounter[this.currFunc]--;
                this.setValueInMemory(result, valResult);
                this.funcCounter[this.currFunc]++;
            }
        }
    }
    /*
    Returns the dim at the index of the dim array.
    */
    getDimAt(index) {
        return this.dim[index];
    }
    /*
    Returns the array in memory as an array depending on the dimensions.
    */
    exportArray(val) {
        if (val.dim === undefined) {
            return;
        }
        var dim = this.getDimAt(val.dim);
        let dimensions = [];
        while (dim !== undefined) {
            dimensions.push(dim.lsup);
            if (dim.next !== undefined) {
                dim = this.getDimAt(dim.next);
            }
            else {
                break;
            }
        }
        let total = dimensions.reduce((a, b) => a * b, 1);
        let res = [];
        for (let i = 2; i <= total + 1; i++) {
            res.push(this.getValueInMemory((val.dir + i).toString()));
        }
        let temp = [];
        if (dimensions.length > 1) {
            dimensions.forEach((element) => {
                while (res.length)
                    temp.push(res.splice(0, element + 1));
            });
        }
        res = temp.length > 0 ? temp : res;
        return res;
    }
    /*
    Sets an array in memory. It is used to modify the existing array.
    */
    importArray(val, arr) {
        if (val.dim === undefined) {
            return;
        }
        var dim = this.getDimAt(val.dim);
        let dimensions = [];
        while (dim !== undefined) {
            dimensions.push(dim.lsup);
            if (dim.next !== undefined) {
                dim = this.getDimAt(dim.next);
            }
            else {
                break;
            }
        }
        let total = dimensions.reduce((a, b) => a * b, 1);
        let res = [];
        for (let i = 2; i <= total + 1; i++) {
            res.push(this.getValueInMemory((val.dir + i).toString()));
            this.setValueInMemory((val.dir + i).toString(), arr[i - 2]);
        }
        return res;
    }
    /*
    Sums all the values in the array and returns the result. This is a helper function.
    */
    sumArray(val) {
        const arr = this.exportArray(val);
        if (arr === undefined) {
            return 0;
        }
        return arr.reduce((partialSum, a) => partialSum + a, 0);
    }
    /*
    Prints an array in the console.
    */
    printArray(val) {
        console.log(this.exportArray(val));
    }
    /*
    Sums all the values in the array and sets the result in memory.
    */
    sum(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                let result = quadruple.result;
                this.setValueInMemory(result, this.sumArray(e));
            }
            else if (arg1[0] === "*") {
                throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Generates a random number and sets it in memory.
    */
    rand(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            let result = quadruple.result;
            const arr = this.getValueInMemory(arg1);
            this.setValueInMemory(result, Math.floor(Math.random() * Number(arr)));
        }
        else {
            console.log("null");
        }
    }
    /*
    Obtains the minimum value in the array and sets it in memory.
    */
    min(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                let result = quadruple.result;
                const arr = this.exportArray(e);
                if (arr === undefined) {
                    throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
                }
                this.setValueInMemory(result, (0, simple_statistics_1.min)(arr));
            }
            else if (arg1[0] === "*") {
                throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Obtains the maximum value in the array and sets it in memory.
    */
    max(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                let result = quadruple.result;
                const arr = this.exportArray(e);
                if (arr === undefined) {
                    throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
                }
                this.setValueInMemory(result, (0, simple_statistics_1.max)(arr));
            }
            else if (arg1[0] === "*") {
                throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Obtains the product of all the values in the array and sets it in memory.
    */
    prod(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                let result = quadruple.result;
                const arr = this.exportArray(e);
                if (arr === undefined) {
                    throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
                }
                this.setValueInMemory(result, (0, simple_statistics_1.product)(arr));
            }
            else if (arg1[0] === "*") {
                throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Obtains the mean of all the values in the array and sets it in memory.
    */
    mean(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                let result = quadruple.result;
                const arr = this.exportArray(e);
                if (arr === undefined) {
                    throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
                }
                this.setValueInMemory(result, (0, simple_statistics_1.mean)(arr));
            }
            else if (arg1[0] === "*") {
                throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Obtains the mode of all the values in the array and sets it in memory.
    */
    mode(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                let result = quadruple.result;
                const arr = this.exportArray(e);
                if (arr === undefined) {
                    throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
                }
                this.setValueInMemory(result, (0, simple_statistics_1.mode)(arr));
            }
            else if (arg1[0] === "*") {
                throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Obtains the median of all the values in the array and sets it in memory.
    */
    median(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                let result = quadruple.result;
                const arr = this.exportArray(e);
                if (arr === undefined) {
                    throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
                }
                this.setValueInMemory(result, (0, simple_statistics_1.median)(arr));
            }
            else if (arg1[0] === "*") {
                throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Sorts all the values in the array and sets it in memory back to the original array.
    */
    sort(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                let result = quadruple.result;
                const arr = this.exportArray(e);
                if (arr === undefined) {
                    throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
                }
                this.importArray(e, arr.sort(function (a, b) {
                    return a - b;
                }));
            }
            else if (arg1[0] === "*") {
                throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Finds the position of a value in the array and sets it in memory.
    */
    find(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1 && arg2) {
            if (e && e.dim !== undefined) {
                let result = quadruple.result;
                const arr = this.exportArray(e);
                if (arr === undefined) {
                    throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
                }
                const val2 = this.getValueInMemory(arg2);
                this.setValueInMemory(result, arr.findIndex((x) => x.toString() === val2));
            }
            else if (arg1[0] === "*") {
                throw new Error(`sum() function can only be used with arrays, not with ${arg1}`);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Gets the sine value of a number and sets it in memory.
    */
    sin(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                throw new Error(`sin() function can't be used with arrays`);
            }
            else if (arg1[0] === "*") {
                const val1 = this.getValueInMemory(arg1);
                const res = Math.sin(this.getValueInMemory((val1 + 1).toString()));
                const resDir = quadruple.result;
                this.setValueInMemory(resDir, res);
            }
            else {
                const res = Math.sin(this.getValueInMemory(arg1));
                const resDir = quadruple.result;
                this.setValueInMemory(resDir, res);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Gets the cosine value of a number and sets it in memory.
    */
    cos(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                throw new Error(`cos() function can't be used with arrays`);
            }
            else if (arg1[0] === "*") {
                const val1 = this.getValueInMemory(arg1);
                const res = Math.cos(this.getValueInMemory((val1 + 1).toString()));
                const resDir = quadruple.result;
                this.setValueInMemory(resDir, res);
            }
            else {
                const res = Math.cos(this.getValueInMemory(arg1));
                const resDir = quadruple.result;
                this.setValueInMemory(resDir, res);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Gets the tanget value of a number and sets it in memory.
    */
    tan(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                throw new Error(`tan() function can't be used with arrays`);
            }
            else if (arg1[0] === "*") {
                const val1 = this.getValueInMemory(arg1);
                const res = Math.tan(this.getValueInMemory((val1 + 1).toString()));
                const resDir = quadruple.result;
                this.setValueInMemory(resDir, res);
            }
            else {
                const res = Math.tan(this.getValueInMemory(arg1));
                const resDir = quadruple.result;
                this.setValueInMemory(resDir, res);
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Prints the chart of an array.
    */
    chart(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                console.log(asciichart.plot(this.exportArray(e)));
            }
            else {
                console.log("nulls");
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Prints a value or an array in the console.
    */
    print(quadruple) {
        const arg1 = quadruple.arg1;
        const e = this.varTable.find((v) => v.dir.toString() === arg1);
        if (arg1) {
            if (e && e.dim !== undefined) {
                this.printArray(e);
            }
            else if (arg1[0] === "*") {
                const val1 = this.getValueInMemory(arg1);
                console.log(this.getValueInMemory((val1 + 1).toString()));
            }
            else {
                console.log(this.getValueInMemory(arg1));
            }
        }
        else {
            console.log("null");
        }
    }
    /*
    Changes the instruction pointer to the result.
    */
    goTo(quadruple) {
        const result = quadruple.result;
        if (result) {
            this.instructionPointer = parseInt(result) - 1;
        }
    }
    /*
    If the value in arg1 is false, ithanges the instruction
    pointer to the result.
    */
    goToF(quadruple) {
        const arg1 = quadruple.arg1;
        const result = quadruple.result;
        if (arg1 && result) {
            if (this.getValueInMemory(arg1) === 0) {
                this.instructionPointer = parseInt(result) - 1;
            }
        }
    }
    /*
    Compares if the value in arg1 is greater than the value in
    arg2 and stores the result in the address from result.
    */
    greaterThan(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1);
            const val2 = this.getValueInMemory(arg2);
            if (Number(val1) > Number(val2)) {
                this.setValueInMemory(result, 1);
            }
            else {
                this.setValueInMemory(result, 0);
            }
        }
    }
    /*
    Compares if the value in arg1 is less than the value in arg2
    and stores the result in the address from result.
    */
    lessThan(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1);
            const val2 = this.getValueInMemory(arg2);
            if (Number(val1) < Number(val2)) {
                this.setValueInMemory(result, 1);
            }
            else {
                this.setValueInMemory(result, 0);
            }
        }
    }
    /*
    Compares if the value in arg1 is greater or equal than the
    value in arg2 and stores the result in the address from result.
    */
    greaterOrEqualThan(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1);
            const val2 = this.getValueInMemory(arg2);
            if (Number(val1) >= Number(val2)) {
                this.setValueInMemory(result, 1);
            }
            else {
                this.setValueInMemory(result, 0);
            }
        }
    }
    /*
    Compares if the value in arg1 is less or equal than the value
    in arg2 and stores the result in the address from result.
    */
    lessOrEqualThan(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1);
            const val2 = this.getValueInMemory(arg2);
            if (Number(val1) <= Number(val2)) {
                this.setValueInMemory(result, 1);
            }
            else {
                this.setValueInMemory(result, 0);
            }
        }
    }
    /*
    Compares if the value in arg1 is equal than the value in
    arg2 and stores the result in the address from result.
    */
    equal(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val2 = this.getValueInMemory(arg2);
            const val1 = this.getValueInMemory(arg1);
            if (val1.toString() === val2.toString()) {
                this.setValueInMemory(result, 1);
            }
            else {
                this.setValueInMemory(result, 0);
            }
        }
    }
    /*
    Compares if the value in arg1 is not equal than the value
    in arg2 and stores the result in the address from result.
    */
    notEqual(quadruple) {
        const arg1 = quadruple.arg1;
        const arg2 = quadruple.arg2;
        const result = quadruple.result;
        if (arg1 && arg2 && result) {
            const val1 = this.getValueInMemory(arg1);
            const val2 = this.getValueInMemory(arg2);
            if (val1.toString() !== val2.toString()) {
                this.setValueInMemory(result, 1);
            }
            else {
                this.setValueInMemory(result, 0);
            }
        }
    }
    /*
    Starts the call of a function. Adds one to the respective
    function counter, adds the function space into memory and
    adds the function call to the function directory.
    */
    era(quadruple) {
        const arg1 = quadruple.arg1;
        if (arg1) {
            if (this.funcCounter[arg1] === undefined) {
                this.dirFunc[arg1].quadCount = this.dirFunc[arg1].quadCount + 1;
            }
            const func = this.dirFunc[arg1 + (this.funcCounter[arg1] ? this.funcCounter[arg1] : "")];
            if (!func) {
                throw new Error(`Function ${func} not found`);
            }
            if (this.funcCounter[arg1] === undefined) {
                this.funcCounter[arg1] = 1;
            }
            else {
                this.funcCounter[arg1]++;
            }
            this.currFunc = arg1;
            this.memory[arg1 + this.funcCounter[arg1]] = newMemoryBatch();
            this.functionStack.push(arg1 + this.funcCounter[arg1]);
            this.dirFunc[arg1 + this.funcCounter[arg1]] = Object.assign({}, this.dirFunc[arg1]);
            this.dirFunc[arg1 + this.funcCounter[arg1]].parameterTable = this.dirFunc[arg1 + this.funcCounter[arg1]].parameterTable.map((p) => {
                return ((Object.keys(this.memory).length - 1) * 100000).toString();
            });
        }
    }
    /*
    Changes the instruction pointer to the position where the function is.
    */
    goSub(quadruple) {
        const arg1 = quadruple.arg1;
        const res = quadruple.result;
        if (arg1) {
            if (this.paramCounter <
                this.dirFunc[this.functionStack.peek()].parameterTable.length) {
                throw new Error("Not enough parameters");
            }
            this.instructionPointerStack.push(this.instructionPointer);
            this.instructionPointer = parseInt(arg1) - 1;
        }
        this.paramCounter = 0;
    }
    /*
    Returns to where the function was called.
    */
    endfunc(quadruple) {
        this.instructionPointer = this.instructionPointerStack.pop();
    }
    /*
    Returns the value in the address from arg1 and stores it in the
    address from result.
    */
    return(quadruple) {
        const arg1 = quadruple.arg1;
        const result = quadruple.result;
        if (arg1 && result) {
            const val1 = this.getValueInMemory(arg1);
            if (this.getAddressType(parseInt(result)) === "int") {
                const valResult = Math.floor(Number(val1));
                this.setValueInMemory(result, valResult);
            }
            else if (this.getAddressType(parseInt(result)) === "float") {
                const valResult = Number(val1);
                this.setValueInMemory(result, valResult);
            }
            else {
                const valResult = val1;
                this.setValueInMemory(result, valResult);
            }
            if (this.returnStack[this.currFunc] === undefined) {
                this.returnStack[this.currFunc] = new stack_1.Stack([
                    this.getValueInMemory(result),
                ]);
            }
            else {
                this.returnStack[this.currFunc].push(this.getValueInMemory(result));
                this.funcCounter[this.currFunc]--;
            }
        }
        const aux = this.quadruples[this.instructionPointerStack.peek()];
        this.instructionPointer = this.instructionPointerStack.pop();
    }
    /*
    Sets the value in the address from arg1 to the parameter of the function.
    */
    param(quadruple) {
        const arg1 = quadruple.arg1;
        if (arg1) {
            if (this.paramCounter >=
                this.dirFunc[this.functionStack.peek() +
                    (this.funcCounter[arg1] ? this.funcCounter[arg1] : "")].parameterTable.length) {
                throw new Error("Too many parameters");
            }
            const val1 = isNaN(this.getValueInMemory(arg1))
                ? 0
                : this.getValueInMemory(arg1);
            const dir = this.dirFunc[this.functionStack.peek() +
                (this.funcCounter[arg1] ? this.funcCounter[arg1] : "")].parameterTable[this.paramCounter];
            if (this.getAddressType(parseInt(dir)) !==
                this.getAddressType(parseInt(arg1))) {
                throw new Error("Type mismatch");
            }
            this.setValueInMemory(dir.toString(), val1);
            this.paramCounter++;
        }
    }
}
module.exports = VirtualMachine;
